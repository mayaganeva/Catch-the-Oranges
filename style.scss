@import url('https://fonts.googleapis.com/css2?family=Maiden+Orange&display=swap');
*, ::before, ::after {
	box-sizing: border-box;
	margin: 0;
	padding: 0;
}
body {
	background-color: #191919;
	color: #fff;
	display: grid;
	font-family: 'Maiden Orange', serif;
	font-weight: 400;
	font-style: normal;
	min-height: 100vh;
	place-items: center;
}
.gameContainer {
	aspect-ratio: 1;
	background-image: url("background.jpg");
	background-size: cover;
	background-position: 50% 0%;
	background-position-x: 50%;
	background-position-y: 0%;
	border-radius: 16px;
	container-type: inline-size;
	// Now we can use container units
	outline: 2px solid #fff;
	overflow: hidden;
	position: relative;
	transition: all 1s;
	width: 80vmin;
	// 90% of the ideal min width of viewport

	&:has(#game:checked) {
		animation: treeShake .1s 1.5s ease-in-out alternate 8;
		background-size: 125%;
		background-position-y: 100%;
		// If worries about performance, the background would be a different element
		// Separated background-position-x because one is translated and the other animated

		@keyframes treeShake {
			from { background-position-x: 45%; }
			to { background-position-x: 55%; }
		}
	}
}
input[name="screen"] {
	// position: relative;
	// z-index: 2;
	display: none;
	// Putting display: none; removes it from the DOM, but doesn't remove it from the CSS Object Model, so CSS treats them just as if they're in the DOM

	&#start:checked ~ .screen-start,
	&#info:checked ~ .screen-info,
	&#game:checked ~ .screen-game,
	&#end:checked ~ .screen-end {
		opacity: 1;
		pointer-events: revert;
	}

	&#game:checked ~ .screen-game .orange {
		animation: orangeDrop 2.5s var(--delay, 0s) ease-in forwards var(--playState, running);

		@keyframes orangeDrop {
			to { translate: var(--translateX, 10cqi) 60cqi; }
		}
	}

	&#info:checked ~ .screen-info:has(.button-label:checked) {
		opacity: 0;
	}

	&#game:checked ~ .screen-end {
		animation: screenEnd .4s 29.5s forwards;
		backdrop-filter: blur(4px);

		@keyframes screenEnd {
			to {
				opacity: 1;
				pointer-events: revert;
			}
		}
	}
}
.screen {
	align-content: center;
	display: grid;
	gap: 5cqi;
	inset: 0;
	opacity: 0;
	position: absolute;
	place-items: center;
	pointer-events: none;
	transition: opacity 400ms;

	&-start {
		.orange:first-child {
			translate: 23cqi -27cqi;
			scale: .9;
			animation: orangeDance 1s infinite alternate ease-in-out;
		}
		.orange:nth-child(2) {
			translate: -22cqi -12cqi;
			rotate: -20deg;
			animation: orangeDance 1s .6s infinite alternate ease-in-out;
		}
		.orange:nth-child(n + 3) {
			animation: orangeDrop .4s 1s ease-in;
			translate: var(--translateX) -60cqi;
		}
		.orange:nth-child(3) {
			--translateX: 10cqi;
		}
		.orange:nth-child(4) {
			--translateX: -35cqi;
			animation-delay: 1.5s;
		}
		.orange:nth-child(5) {
			--translateX: 5cqi;
			animation-delay: 2.5s;
		}
		@keyframes orangeDance {
			from { rotate: 25deg; }
			to { rotate: -23deg; }
		}
	}
	&-info {
		background-color: #191919aa;
		padding: 10cqi;
	}
	&-info p {
		font-size: 4.5cqi;
	}
	&-end {
		background-color: #fffa;
		color: #000;
		font-size: 5cqi;
	}
}
h1 {
	font-size: 12cqi;
	text-shadow: 1cqi 1cqi 3cqi #000c;
	// Use the same units thatyou use on the game container for everything else
	transform: skewY(-5deg);
	user-select: none;
}
.buttons {
	display: flex;
	gap: 5cqi;
}
.button-label {
	border: max(.5cqi, 2px) solid hsla(34, 91%, 49%, 0.5);
	border-radius: 16px;
	box-shadow: 1cqi 1cqi 3cqi hsla(27, 95%, 25%, 0.8);
	// He wouldnt set it at just .5cqi so the border doesn't become too thin
	// 1cqi is 1% of the container width
	font-family: 'Maiden Orange', serif;
	font-size: 6cqi;
	background-color: hsla(34, 91%, 49%, 0.5);
	color: #fff;
	padding: .8em 1.3em;
	scale: 1;
	transform: skewY(-5deg);
	transition: scale 250ms ease;
	user-select: none;
}
.button-label:hover {
	cursor: pointer;
	scale: 1.1;
}
.screen-info .button-label {
	padding: .5em 1em;
}
.screen-end .button-label {
	background-color: rgba(255, 68, 0, 0.8);
	border-color: orangered;
}
.oranges {
	position: absolute;
	inset: 50%;
	// In the middle of the screen
}
.orange {
	appearance: none;
	// Resets appearance of radio to an empty div
	background-image: radial-gradient(circle at top, orange, maroon);
	background-image: radial-gradient(
		circle at top,
		orange,
		hsl(24, 100%, 50%),
		maroon
		);
	border-radius: 50%;
	box-shadow: .25cqi .75cqi 2cqi rgba(85, 43, 3, .6);
	inset: -5cqi;
	// It's going outside, outset of 5cqi, so total width is 10cqi, 5 in each direction
	position: absolute;

	&::before, &::after {
		aspect-ratio: 1;
		background-image: radial-gradient(
			at top left,
			green,
			limegreen
		);
		border-radius: 0 100%;
		content: '';
		left: 50%;
		top: 10%;
		transform-origin: top left;
		position: absolute;
		rotate: 170deg;
		width: 40%;
	}

	&::after {
		rotate: -90deg;
	}

	&[type="radio"] {
		rotate: var(--angle);
		scale: var(--scale);
		translate: var(--translateX) -60cqi;
		transition: opacity 200ms;

		@for $o from 1 through 30 {
			&:nth-child(#{$o}) {
				// Sass variables are "meant" to be used as value only; In order to use them elsewhere, we need to use interpolation
				--angle: #{random(60) - 30}deg;
				// You HAVE TO use interpolation when using custom properties with Sass
				--delay: #{$o + 2}s;
				--scale: #{random(100) / 500 + 0.8};
				// 100 / 100 gives a number between 0 1 and 100 / 500 gives a number from 0 to 0.2 + 0.8 to get 1
				--translateX: #{random(80) - 40}cqi;
				// Getting a random number between -40 to 40
			}
		}

		&:hover {
			box-shadow: 0 1cqi 3cqi rgba(85, 43, 3, .6);
			cursor: pointer;
		}

		#game:checked ~ .screen-game &:checked {
			--playState: paused;
			// Firefox doesn't like when you change custom properties? Check that
			background-color: #fff;
			background-image: unset;
			box-shadow: unset;
			-webkit-mask: url('pop.svg') no-repeat center;
			mask: url('pop.svg') no-repeat center;
			-webkit-mask-size: contain;
			mask-size: contain;
			opacity: 0;
			transform: translateY(-25%);
			// Happens after the original transform is finished
		}

		&:checked::before,
		&:checked::after {
			background-image: revert;
		}
	}
}